// Contains the implementation of a LSP server.

package lsp

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"

	"github.com/cmu440/lspnet"
)

func (s *server) handleReadPerClient(client_id int, stopCh chan struct{}, entryCh chan struct{}) {
	s.connIDToClientLock <- struct{}{}
	client := s.connIDToClient[client_id]
	<-s.connIDToClientLock //TODO: problems here, 下面会有race
	for {
		select {
		case <-stopCh:
			return
		default:
			var curPqReadTop *Message
			for curPqReadTop == nil { // in case every client has no message to read
				top := client.pqRead.Top()
				if top != nil {
					curPqReadTop = top.(*Message)
				}
			}
			curReadSeqNum := client.currentReadSeqNum
			if (curReadSeqNum + 1) == (curPqReadTop.SeqNum) {
				select {
				case entryCh <- struct{}{}: //block other client routines
					client.pqRead.Pop()
					s.readChannel <- curPqReadTop
					client.currentReadSeqNum++

					// ackMsg := NewAck(client_id, curPqReadTop.SeqNum)
					// go s.SendMessage(ackMsg)
					close(stopCh)
				case <-stopCh:
					return
				}

			}

		}
	}

}

type s_PendingMessageQueueOp struct {
	opType           string // "keepPop" or "insert" or "init"
	s_pendingMessage *Message
	connID           int
}

func (s *server) PendingMessageKeepPop(client *clientStruct) {
	curLeftWindowSize := client.windowSizeLeft

	curWriteSeqNum := client.currentWriteSeqNum

	curAckNum := client.currentAckNum

	pendMessageQueue := client.pendingMessageQueue
	if pendMessageQueue.IsEmpty() {
		return
	}
	for (pendMessageQueue.Peek().(*Message).SeqNum <= curLeftWindowSize+s.params.WindowSize-1) &&
		((curWriteSeqNum - curAckNum) <= s.params.MaxUnackedMessages) {

		pendingMessage := pendMessageQueue.Peek().(*Message)

		pendMessageQueue.Dequeue() // Now it is safe to dequeue, we already have all needed info

		go s.SendMessage(pendingMessage)
	}
}

func (s *server) SendMessage(messageToSend *Message) {

	s.connIDToClientLock <- struct{}{}
	client := s.connIDToClient[messageToSend.ConnID]
	udpAddr := client.udpAddr
	<-s.connIDToClientLock

	jsonData, err := json.Marshal(messageToSend)
	if err != nil {
		log.Printf("Error encoding message: %v", err)
		return
	}

	if _, err := s.conn.WriteToUDP(jsonData, udpAddr); err != nil {
		log.Printf("Error sending message: %v", err)
	}
}

type messagewithUDP struct {
	udpAddr *lspnet.UDPAddr
	msg     Message //message
}

type clientStruct struct {
	connID              int
	udpAddr             *lspnet.UDPAddr
	windowSizeLeft      int
	currentReadSeqNum   int
	currentWriteSeqNum  int
	currentAckNum       int
	pendingMessageQueue *Queue
	pqRead              *PriorityQueue
	pqACK               *PriorityQueue
}

type server struct {
	// addrToConnID map[*lspnet.UDPAddr]int

	// connIDToAddr map[int]*lspnet.UDPAddr
	// connIDToAddrLock chan struct{}

	// windowSizeLeft map[int]int
	// LeftWindowSizeLock chan struct{}

	// currentReadSeqNum map[int]int
	// currentReadSeqNumLock chan struct{}

	// currentWriteSeqNum map[int]int
	// currentWriteSeqNumOpLock chan struct{}

	// currentAckNum map[int]int
	// currentAckNumLock chan struct{}

	// pendingMessageQueue       map[int]*Queue //888
	// pendingMessageQueueOpChan chan s_PendingMessageQueueOp
	// PendingMessageQueueLock   chan struct{}

	// pqRead map[int]*PriorityQueue
	// pqReadLock chan struct{}

	// pqACK map[int]*PriorityQueue //**

	//// pqACKOpChan               chan pqACKOp

	conn                 *lspnet.UDPConn
	readChannel          chan *Message
	connID               int
	readSigChan          chan struct{}
	params               Params
	serverMessageChannel chan messagewithUDP
	closeChannel         chan struct{}

	connIDToClient     map[int]*clientStruct
	connIDToClientLock chan struct{}

	currentConnID     int // generated by server, give to client, plus 1 every time
	currentConnIDLock chan struct{}
}

func (s *server) readProcessRoutine() {
	buf := make([]byte, 2048)
	for {
		n, addr, err := s.conn.ReadFromUDP(buf)
		if err != nil {
			log.Println("Read Error: ", err)
			continue
		}
		var msg Message
		// use json.Unmarshal
		if err := json.Unmarshal(buf[:n], &msg); err != nil {
			log.Println("Decode Error: ", err)
			continue
		}

		if msg.Type == MsgData {
			ackMsg := NewAck(msg.ConnID, msg.SeqNum)
			go s.SendMessage(ackMsg)

		}

		msgWithUDP := messagewithUDP{
			udpAddr: addr,
			msg:     msg,
		}

		s.serverMessageChannel <- msgWithUDP
	}
}

func (s *server) mainRoutine() {
	for {
		select {
		case <-s.closeChannel:
			return
		case messagewithUDP := <-s.serverMessageChannel:
			msg := messagewithUDP.msg
			msgUDPaddr := messagewithUDP.udpAddr
			if msg.Type == MsgConnect {

				s.currentConnIDLock <- struct{}{}
				s.currentConnID++
				currentConnID_toClient := s.currentConnID
				<-s.currentConnIDLock
				ackMsg := NewAck(currentConnID_toClient, msg.SeqNum)
				go s.SendMessage(ackMsg)

				s.connIDToClientLock <- struct{}{}
				s.connIDToClient[currentConnID_toClient] = &clientStruct{
					connID:              currentConnID_toClient,
					udpAddr:             msgUDPaddr,
					pendingMessageQueue: NewQueue(),
					pqRead:              NewPriorityQueue(),
					pqACK:               NewPriorityQueue(),
					currentAckNum:       msg.SeqNum,
					currentReadSeqNum:   msg.SeqNum,
					currentWriteSeqNum:  msg.SeqNum,
					windowSizeLeft:      msg.SeqNum + 1,
				}
				<-s.connIDToClientLock
				// ackMsg := NewAck(currentConnID_toClient, msg.SeqNum)
				// go s.SendMessage(ackMsg)

			} else if msg.Type == MsgData {
				// ackMsg := NewAck(msg.ConnID, msg.SeqNum)
				// go s.SendMessage(ackMsg)

				newPqReadMessage := Message{
					SeqNum:  msg.SeqNum,
					Payload: msg.Payload,
					ConnID:  msg.ConnID,
				}

				s.connIDToClientLock <- struct{}{}
				client := s.connIDToClient[msg.ConnID]
				client.pqRead.Insert(&newPqReadMessage, float64(msg.SeqNum))
				<-s.connIDToClientLock

			} else if msg.Type == MsgAck {
				s.connIDToClientLock <- struct{}{}
				client := s.connIDToClient[msg.ConnID]
				client.currentAckNum++
				curLeftWindowSize := client.windowSizeLeft
				if msg.SeqNum == (curLeftWindowSize) {
					/*update leftWindow */
					client.windowSizeLeft++

					/*update continuously from pqACK queue*/
					lastLeft := msg.SeqNum
					pqACK := client.pqACK
					// pqACK, ok := s.pqACK[msg.ConnID]

					for pqACK.Len() > 0 {
						if (lastLeft) == pqACK.Top().(int) {
							lastLeft++
							pqACK.Pop()
							client.windowSizeLeft++
						} else {
							break
						}
					}
					s.PendingMessageKeepPop(client)

				} else {

					pqACK := client.pqACK
					pqACK.Insert(msg.SeqNum, float64(msg.SeqNum))
				}
				<-s.connIDToClientLock

			} else if msg.Type == MsgCAck {
				s.connIDToClientLock <- struct{}{}
				client := s.connIDToClient[msg.ConnID]

				curLeftWindowSize := client.windowSizeLeft
				client.currentAckNum = msg.SeqNum

				if msg.SeqNum >= (curLeftWindowSize) {
					pqACK := client.pqACK
					for {
						if pqACK.Len() > 0 && msg.SeqNum >= pqACK.Top().(int) {
							pqACK.Pop()
						} else {
							break
						}
					}

					lastLeft := msg.SeqNum
					for {
						if pqACK.Len() != 0 && (lastLeft) == pqACK.Top().(int) {
							lastLeft++
							pqACK.Pop()
							// s.LeftWindowSizeOpChan <- plusOp
							client.windowSizeLeft++
						} else {
							break
						}
					}
					client.windowSizeLeft = lastLeft
					s.PendingMessageKeepPop(client)
				}
				<-s.connIDToClientLock

			}
		case <-s.readSigChan:
			// log.Print("Server start a new readServerProcess()")
			go s.readServerProcess()
		}
	}
}

func (s *server) readServerProcess() {

	s.currentConnIDLock <- struct{}{}
	currentClientConnIDMax := s.currentConnID
	<-s.currentConnIDLock

	for currentClientConnIDMax == 0 {

		s.currentConnIDLock <- struct{}{}
		currentClientConnIDMax = s.currentConnID
		<-s.currentConnIDLock
	}
	stopCh := make(chan struct{})
	entryCh := make(chan struct{}, 1)
	for client_id := 1; client_id <= currentClientConnIDMax; client_id++ {
		go s.handleReadPerClient(client_id, stopCh, entryCh)
	}
	// <-stopCh //no need to wait
}

// NewServer creates, initiates, and returns a new server. This function should
// NOT block. Instead, it should spawn one or more goroutines (to handle things
// like accepting incoming client connections, triggering epoch events at
// fixed intervals, synchronizing events using a for-select loop like you saw in
// project 0, etc.) and immediately return. It should return a non-nil error if
// there was an error resolving or listening on the specified port number.
func NewServer(port int, params *Params) (Server, error) {
	// log.Print("NewServer9999")
	laddr, err := lspnet.ResolveUDPAddr("udp", fmt.Sprintf(":%d", port))
	if err != nil {
		return nil, err
	}
	conn, err := lspnet.ListenUDP("udp", laddr)
	if err != nil {
		return nil, err
	}
	s := &server{
		conn:                 conn,
		readChannel:          make(chan *Message),
		readSigChan:          make(chan struct{}),
		params:               *params,
		connID:               0,
		serverMessageChannel: make(chan messagewithUDP),
		closeChannel:         make(chan struct{}),

		currentConnID: 0,
		// currentConnIDOpChan: make(chan s_currentConnIDOp),
		currentConnIDLock: make(chan struct{}, 1),

		connIDToClient:     make(map[int]*clientStruct),
		connIDToClientLock: make(chan struct{}, 1),

		// pendingMessageQueue:       make(map[int]*Queue),
		// pendingMessageQueueOpChan: make(chan s_PendingMessageQueueOp),
		// PendingMessageQueueLock:   make(chan struct{}, 1),

		// windowSizeLeft: make(map[int]int),
		// // LeftWindowSizeOpChan: make(chan s_LeftWindowSizeOp),
		// LeftWindowSizeLock: make(chan struct{}, 1),

		// currentWriteSeqNum: make(map[int]int),
		// // currentWriteSeqNumOpChan: make(chan s_currentWriteSeqNumOp),
		// currentWriteSeqNumOpLock: make(chan struct{}, 1),

		// currentReadSeqNum: make(map[int]int),
		// // currentReadSeqNumOpChan: make(chan s_currentReadSeqNumOp),
		// currentReadSeqNumLock: make(chan struct{}, 1),

		// currentAckNum: make(map[int]int),
		// // currentAckNumOpChan: make(chan s_currentAckNumOp),
		// currentAckNumLock: make(chan struct{}, 1),

		// connIDToAddr: make(map[int]*lspnet.UDPAddr),
		// // connIDToAddrOpChan: make(chan s_connIDToAddrOp),
		// connIDToAddrLock: make(chan struct{}, 1),

		// pqRead: make(map[int]*PriorityQueue),
		// // PqReadOpChan:       make(chan s_pqReadOp),
		// pqReadLock: make(chan struct{}, 1),

		// pqACK: make(map[int]*PriorityQueue),
		// // pqACKOpChan:               make(chan pqACKOp),

	}

	go s.readProcessRoutine()
	go s.mainRoutine()

	return s, nil
}

func (s *server) Read() (int, []byte, error) {
	// log.Print("Server Read() is called")

	s.readSigChan <- struct{}{}
	for {
		// log.Print("enter for loop in server Read()")
		select {
		case data, ok := <-s.readChannel:
			// log.Print("Server readChannel do get data.")
			if !ok {
				// readChannel 已关闭
				return data.ConnID, nil, errors.New("readChannel has been closed")
			}
			return data.ConnID, data.Payload, nil
		case <-s.closeChannel:
			return s.connID, nil, errors.New("server has been closed")
		}
	}
}

func (s *server) Write(connId int, payload []byte) error {

	s.connIDToClientLock <- struct{}{}
	client := s.connIDToClient[connId]
	client.currentWriteSeqNum++
	curLeftWindowSize := client.windowSizeLeft
	curWriteSeqNum := client.currentWriteSeqNum
	curAckNum := client.currentAckNum
	if (curWriteSeqNum <= curLeftWindowSize+s.params.WindowSize-1) &&
		((curWriteSeqNum - curAckNum) <= s.params.MaxUnackedMessages) {

		messageToSend := NewData(connId, curWriteSeqNum, int(len(payload)), payload,
			CalculateChecksum(connId, curWriteSeqNum, int(len(payload)), payload))
		go s.SendMessage(messageToSend)

		// log.Printf("Server finished write")
	} else {
		client.pendingMessageQueue.Enqueue(&Message{
			SeqNum:  curWriteSeqNum,
			Payload: payload,
			ConnID:  connId,
		})
	}
	<-s.connIDToClientLock

	return nil
}

func (s *server) CloseConn(connId int) error {
	return errors.New("not yet implemented")
}

func (s *server) Close() error {
	s.closeChannel <- struct{}{}
	return s.conn.Close()
}
